using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

namespace TestsGenerator
{
    [Generator]
    public class CustomSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(
                ctx => ctx.AddSource("MultistepAttribute.g.cs", SourceText.From(MultistepAttribute.Code, Encoding.UTF8)));
            context.RegisterPostInitializationOutput(
                ctx => ctx.AddSource("MultistepParticipantAttribute.g.cs", SourceText.From(MultistepParticipant.Code, Encoding.UTF8)));



            // Step 1: Find all class declarations with [Serializable]
            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsCandidate(s), // quick filter
                    transform: static (ctx, _) => GetSemanticTarget(ctx)) // get symbol
                .Where(static m => m is not null)!;

            // Step 2: Generate code for each matched class
            context.RegisterSourceOutput(classDeclarations, static (spc, classSymbol) =>
            {
                GenerateSerializer(spc, classSymbol!);
            });
        }

        private static bool IsCandidate(SyntaxNode node) =>
            node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0;

        private static INamedTypeSymbol? GetSemanticTarget(GeneratorSyntaxContext context)
        {
            var classDecl = (ClassDeclarationSyntax)context.Node;
            var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
            if (symbol == null) return null;

            var multistepAttr = context.SemanticModel.Compilation
                .GetTypeByMetadataName("TestsGenerator.Abstractions.MultistepAttribute");

            if (multistepAttr == null) return null;

            // Only pick classes with [Serializable]
            return symbol.GetAttributes().Any(a =>
                SymbolEqualityComparer.Default.Equals(a.AttributeClass, multistepAttr))
                ? symbol
                : null;
        }

        private static void GenerateSerializer(SourceProductionContext context, INamedTypeSymbol classSymbol)
        {
            // context.ReportDiagnostic()

            var ns = classSymbol.ContainingNamespace.ToDisplayString();
            var className = classSymbol.Name;

            var tests = classSymbol.GetMembers()
                .OfType<IMethodSymbol>()
                .Where(m => m.GetAttributes().Any(a => a.AttributeClass.Name.Equals("MultistepParticipantAttribute")))
                .OrderBy(t => t.Parameters.Count())
                .ToArray();
            var dependencyGraph = new Dictionary<IMethodSymbol, List<IMethodSymbol>>(SymbolEqualityComparer.Default);
            foreach (var test in tests)
            {
                dependencyGraph[test] = new List<IMethodSymbol>();
                foreach (var param in test.Parameters)
                {
                    var dependency = tests.FirstOrDefault(t => SymbolEqualityComparer.Default.Equals(t.ReturnType, param.Type));
                    if (dependency != null)
                    {
                        dependencyGraph[test].Add(dependency);
                    }
                }
            }
            var sortedTests = TopologicalSort(dependencyGraph);

            // var writer = new IndentedTextWriter();

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine($"//{DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine();
            sb.AppendLine("using NUnit.Framework;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine();
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
            sb.AppendLine($"  public partial class {className}");
            sb.AppendLine("  {");

            // sb.AppendLine("    private Dictionary<string, object> dependencies = new Dictionary<string, object>();");
            sb.AppendLine();

            for (var i = 0; i < sortedTests.Count; i++)
            {
                var test = tests[i];


                if (test.ReturnsVoid)
                {
                    sb.AppendLine($"    [Test, Order({i})]");
                    sb.AppendLine($"    public void {test.Name}Generated()");
                    sb.AppendLine("    {");

                    sb.Append($"      this.{test.Name}(");
                    var requires = dependencyGraph[test].ToDictionary(k => k.ReturnType, v => v, SymbolEqualityComparer.Default);
                    for (var j = 0; j < test.Parameters.Count(); j++)
                    {
                        var param = test.Parameters[j];
                        #region has no returning remove method
                        var requiredTest = requires[param.Type];
                        requires.Remove(param.Type);
                        #endregion
                        sb.Append($"returnedFrom{requiredTest.Name}");
                        if (j < test.Parameters.Count() - 1)
                        {
                            sb.Append(",");
                        }
                    }
                    sb.AppendLine(");");

                    sb.AppendLine("    }");
                    sb.AppendLine();
                }
                else
                {
                    sb.AppendLine($"    private {test.ReturnType.Name} returnedFrom{test.Name};");
                    sb.AppendLine($"    [Test, Order({i})]");
                    sb.AppendLine($"    public void {test.Name}Generated()");
                    sb.AppendLine("    {");

                    sb.Append($"      this.returnedFrom{test.Name} = this.{test.Name}(");
                    var requires = dependencyGraph[test].ToDictionary(k => k.ReturnType, v => v, SymbolEqualityComparer.Default);
                    for (var j = 0; j < test.Parameters.Count(); j++)
                    {
                        var param = test.Parameters[j];
                        #region has no returning remove method
                        var requiredTest = requires[param.Type];
                        requires.Remove(param.Type);
                        #endregion
                        sb.Append($"returnedFrom{requiredTest.Name}");
                        if (j < test.Parameters.Count() - 1)
                        {
                            sb.Append(",");
                        }
                    }
                    sb.AppendLine(");");

                    sb.AppendLine("    }");
                    sb.AppendLine();
                }
            }

            sb.AppendLine("  }"); // class
            sb.AppendLine("}");   // namespace

            context.AddSource($"{className}Multistep.Incremental.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static List<IMethodSymbol> TopologicalSort(Dictionary<IMethodSymbol, List<IMethodSymbol>> graph)
        {
            var sorted = new List<IMethodSymbol>();
            var visited = new HashSet<IMethodSymbol>();
            var visiting = new HashSet<IMethodSymbol>();

            void Visit(IMethodSymbol node)
            {
                if (visited.Contains(node)) return;
                if (visiting.Contains(node))
                {
                    throw new InvalidOperationException("Cyclic dependency detected in test methods.");
                }

                visiting.Add(node);
                foreach (var dependency in graph[node])
                {
                    Visit(dependency);
                }
                visiting.Remove(node);
                visited.Add(node);
                sorted.Add(node);
            }

            foreach (var node in graph.Keys)
            {
                Visit(node);
            }

            return sorted;
        }
    }
}
